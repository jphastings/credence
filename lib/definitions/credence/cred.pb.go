// Code generated by protoc-gen-go.
// source: cred.proto
// DO NOT EDIT!

/*
Package credence is a generated protocol buffer package.

It is generated from these files:
	cred.proto
	identity_assertion.proto
	message.proto
	search_request.proto
	search_result.proto

It has these top-level messages:
	Cred
	IdentityAssertion
	Message
	SearchRequest
	SearchResult
*/
package credence

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type Cred_AssertionType int32

const (
	Cred_NO_COMMENT   Cred_AssertionType = 0
	Cred_IS_TRUE      Cred_AssertionType = 1
	Cred_IS_FALSE     Cred_AssertionType = 2
	Cred_IS_AMBIGUOUS Cred_AssertionType = 3
)

var Cred_AssertionType_name = map[int32]string{
	0: "NO_COMMENT",
	1: "IS_TRUE",
	2: "IS_FALSE",
	3: "IS_AMBIGUOUS",
}
var Cred_AssertionType_value = map[string]int32{
	"NO_COMMENT":   0,
	"IS_TRUE":      1,
	"IS_FALSE":     2,
	"IS_AMBIGUOUS": 3,
}

func (x Cred_AssertionType) String() string {
	return proto.EnumName(Cred_AssertionType_name, int32(x))
}
func (Cred_AssertionType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0, 0} }

// A cred is a definition of a statement, and a timestamped
// assertion as to whether the author believes it to be
// factually correct, incorrect, ambiguous or something
// explicitly worth not commenting on.
type Cred struct {
	// The source URI for the statement
	SourceUri string `protobuf:"bytes,1,opt,name=source_uri" json:"source_uri,omitempty"`
	// UNIX epoch of the time this cred was created
	Timestamp int64 `protobuf:"varint,2,opt,name=timestamp" json:"timestamp,omitempty"`
	// Whether we are asserting the statement is true, false, ambiguous or we're making a null assertion.
	Assertion Cred_AssertionType `protobuf:"varint,3,opt,name=assertion,enum=credence.Cred_AssertionType" json:"assertion,omitempty"`
	// An optional URI which the author claims proves the assertion as to the statement.
	ProofUri string `protobuf:"bytes,4,opt,name=proof_uri" json:"proof_uri,omitempty"`
	// The DSA Signature of this protobuf encoded cred (while signature is set to empty string)
	Signature []byte `protobuf:"bytes,5,opt,name=signature,proto3" json:"signature,omitempty"`
	// The fingerprint of the key used to sign this cred, if the author wishes to make it public
	AuthorFingerprint []byte `protobuf:"bytes,6,opt,name=author_fingerprint,proto3" json:"author_fingerprint,omitempty"`
	// No statement is the equivalent of an "I exist"
	// which could be false (if your private key is compomised)
	// or no comment which is the equivalent of a cred no-op.
	//
	// Types that are valid to be assigned to Statement:
	//	*Cred_HumanReadable
	//	*Cred_CredSeen
	//	*Cred_ApplicationSpecific
	//	*Cred_IdentityDeclaration
	Statement isCred_Statement `protobuf_oneof:"statement"`
}

func (m *Cred) Reset()                    { *m = Cred{} }
func (m *Cred) String() string            { return proto.CompactTextString(m) }
func (*Cred) ProtoMessage()               {}
func (*Cred) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type isCred_Statement interface {
	isCred_Statement()
}

type Cred_HumanReadable struct {
	HumanReadable *Cred_HumanReadableStatement `protobuf:"bytes,7,opt,name=human_readable,oneof"`
}
type Cred_CredSeen struct {
	CredSeen *Cred_CredSeenStatement `protobuf:"bytes,8,opt,name=cred_seen,oneof"`
}
type Cred_ApplicationSpecific struct {
	ApplicationSpecific *Cred_ApplicationSpecificStatement `protobuf:"bytes,9,opt,name=application_specific,oneof"`
}
type Cred_IdentityDeclaration struct {
	IdentityDeclaration *Cred_IdentityDeclarationStatement `protobuf:"bytes,10,opt,name=identity_declaration,oneof"`
}

func (*Cred_HumanReadable) isCred_Statement()       {}
func (*Cred_CredSeen) isCred_Statement()            {}
func (*Cred_ApplicationSpecific) isCred_Statement() {}
func (*Cred_IdentityDeclaration) isCred_Statement() {}

func (m *Cred) GetStatement() isCred_Statement {
	if m != nil {
		return m.Statement
	}
	return nil
}

func (m *Cred) GetHumanReadable() *Cred_HumanReadableStatement {
	if x, ok := m.GetStatement().(*Cred_HumanReadable); ok {
		return x.HumanReadable
	}
	return nil
}

func (m *Cred) GetCredSeen() *Cred_CredSeenStatement {
	if x, ok := m.GetStatement().(*Cred_CredSeen); ok {
		return x.CredSeen
	}
	return nil
}

func (m *Cred) GetApplicationSpecific() *Cred_ApplicationSpecificStatement {
	if x, ok := m.GetStatement().(*Cred_ApplicationSpecific); ok {
		return x.ApplicationSpecific
	}
	return nil
}

func (m *Cred) GetIdentityDeclaration() *Cred_IdentityDeclarationStatement {
	if x, ok := m.GetStatement().(*Cred_IdentityDeclaration); ok {
		return x.IdentityDeclaration
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Cred) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Cred_OneofMarshaler, _Cred_OneofUnmarshaler, _Cred_OneofSizer, []interface{}{
		(*Cred_HumanReadable)(nil),
		(*Cred_CredSeen)(nil),
		(*Cred_ApplicationSpecific)(nil),
		(*Cred_IdentityDeclaration)(nil),
	}
}

func _Cred_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Cred)
	// statement
	switch x := m.Statement.(type) {
	case *Cred_HumanReadable:
		b.EncodeVarint(7<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.HumanReadable); err != nil {
			return err
		}
	case *Cred_CredSeen:
		b.EncodeVarint(8<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.CredSeen); err != nil {
			return err
		}
	case *Cred_ApplicationSpecific:
		b.EncodeVarint(9<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ApplicationSpecific); err != nil {
			return err
		}
	case *Cred_IdentityDeclaration:
		b.EncodeVarint(10<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.IdentityDeclaration); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Cred.Statement has unexpected type %T", x)
	}
	return nil
}

func _Cred_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Cred)
	switch tag {
	case 7: // statement.human_readable
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Cred_HumanReadableStatement)
		err := b.DecodeMessage(msg)
		m.Statement = &Cred_HumanReadable{msg}
		return true, err
	case 8: // statement.cred_seen
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Cred_CredSeenStatement)
		err := b.DecodeMessage(msg)
		m.Statement = &Cred_CredSeen{msg}
		return true, err
	case 9: // statement.application_specific
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Cred_ApplicationSpecificStatement)
		err := b.DecodeMessage(msg)
		m.Statement = &Cred_ApplicationSpecific{msg}
		return true, err
	case 10: // statement.identity_declaration
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Cred_IdentityDeclarationStatement)
		err := b.DecodeMessage(msg)
		m.Statement = &Cred_IdentityDeclaration{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Cred_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Cred)
	// statement
	switch x := m.Statement.(type) {
	case *Cred_HumanReadable:
		s := proto.Size(x.HumanReadable)
		n += proto.SizeVarint(7<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Cred_CredSeen:
		s := proto.Size(x.CredSeen)
		n += proto.SizeVarint(8<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Cred_ApplicationSpecific:
		s := proto.Size(x.ApplicationSpecific)
		n += proto.SizeVarint(9<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Cred_IdentityDeclaration:
		s := proto.Size(x.IdentityDeclaration)
		n += proto.SizeVarint(10<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type Cred_HumanReadableStatement struct {
	Statement string `protobuf:"bytes,1,opt,name=statement" json:"statement,omitempty"`
}

func (m *Cred_HumanReadableStatement) Reset()                    { *m = Cred_HumanReadableStatement{} }
func (m *Cred_HumanReadableStatement) String() string            { return proto.CompactTextString(m) }
func (*Cred_HumanReadableStatement) ProtoMessage()               {}
func (*Cred_HumanReadableStatement) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0, 0} }

type Cred_CredSeenStatement struct {
	CredHash string `protobuf:"bytes,1,opt,name=cred_hash" json:"cred_hash,omitempty"`
}

func (m *Cred_CredSeenStatement) Reset()                    { *m = Cred_CredSeenStatement{} }
func (m *Cred_CredSeenStatement) String() string            { return proto.CompactTextString(m) }
func (*Cred_CredSeenStatement) ProtoMessage()               {}
func (*Cred_CredSeenStatement) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0, 1} }

type Cred_ApplicationSpecificStatement struct {
	Statement []byte `protobuf:"bytes,1,opt,name=statement,proto3" json:"statement,omitempty"`
	// A URI which can be used to determine what application created the statement
	ApplicationUri string `protobuf:"bytes,2,opt,name=application_uri" json:"application_uri,omitempty"`
}

func (m *Cred_ApplicationSpecificStatement) Reset()         { *m = Cred_ApplicationSpecificStatement{} }
func (m *Cred_ApplicationSpecificStatement) String() string { return proto.CompactTextString(m) }
func (*Cred_ApplicationSpecificStatement) ProtoMessage()    {}
func (*Cred_ApplicationSpecificStatement) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{0, 2}
}

type Cred_IdentityDeclarationStatement struct {
	// A public key in DER format which can be used to check the
	// signature of this message to confirm it's veracity
	PublicKey []byte `protobuf:"bytes,1,opt,name=public_key,proto3" json:"public_key,omitempty"`
	// The identity being referenced eg. the URI for a twitter handle
	IdentityUri string `protobuf:"bytes,2,opt,name=identity_uri" json:"identity_uri,omitempty"`
}

func (m *Cred_IdentityDeclarationStatement) Reset()         { *m = Cred_IdentityDeclarationStatement{} }
func (m *Cred_IdentityDeclarationStatement) String() string { return proto.CompactTextString(m) }
func (*Cred_IdentityDeclarationStatement) ProtoMessage()    {}
func (*Cred_IdentityDeclarationStatement) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{0, 3}
}

func init() {
	proto.RegisterType((*Cred)(nil), "credence.Cred")
	proto.RegisterType((*Cred_HumanReadableStatement)(nil), "credence.Cred.HumanReadableStatement")
	proto.RegisterType((*Cred_CredSeenStatement)(nil), "credence.Cred.CredSeenStatement")
	proto.RegisterType((*Cred_ApplicationSpecificStatement)(nil), "credence.Cred.ApplicationSpecificStatement")
	proto.RegisterType((*Cred_IdentityDeclarationStatement)(nil), "credence.Cred.IdentityDeclarationStatement")
	proto.RegisterEnum("credence.Cred_AssertionType", Cred_AssertionType_name, Cred_AssertionType_value)
}

var fileDescriptor0 = []byte{
	// 428 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x7c, 0x93, 0x4f, 0x6f, 0x1a, 0x31,
	0x10, 0xc5, 0x03, 0xe4, 0x0f, 0x3b, 0x6c, 0xe9, 0xc6, 0x8a, 0x5a, 0x0b, 0x71, 0x88, 0x22, 0xb5,
	0xaa, 0x14, 0x89, 0x4a, 0xa9, 0x7a, 0xae, 0x48, 0x4a, 0x0b, 0x6d, 0x08, 0x52, 0x16, 0xce, 0x96,
	0x59, 0x86, 0x60, 0x15, 0xbc, 0x96, 0xed, 0x3d, 0xf0, 0xcd, 0x7b, 0xac, 0xed, 0x2e, 0x09, 0x21,
	0x11, 0x97, 0xd5, 0xce, 0xcc, 0x9b, 0x9f, 0xf5, 0xc6, 0x63, 0x80, 0x4c, 0xe3, 0xac, 0xa3, 0x74,
	0x6e, 0x73, 0x52, 0xf7, 0xff, 0x28, 0x33, 0xbc, 0xf8, 0x7b, 0x04, 0x87, 0x37, 0x2e, 0x20, 0x04,
	0xc0, 0xe4, 0x85, 0xce, 0x90, 0x15, 0x5a, 0xd0, 0xca, 0x79, 0xe5, 0x53, 0x44, 0x4e, 0x21, 0xb2,
	0x62, 0x85, 0xc6, 0xf2, 0x95, 0xa2, 0x55, 0x97, 0xaa, 0x91, 0xcf, 0x10, 0x71, 0x63, 0x50, 0x5b,
	0x91, 0x4b, 0x5a, 0x73, 0xa9, 0xe6, 0x55, 0xbb, 0xb3, 0xa1, 0x75, 0x3c, 0xa9, 0xd3, 0xdd, 0xd4,
	0xc7, 0x6b, 0x85, 0x9e, 0xe1, 0xce, 0xcc, 0xe7, 0x01, 0x7b, 0xb8, 0xc1, 0x1a, 0xf1, 0x20, 0xb9,
	0x2d, 0x34, 0xd2, 0x23, 0x97, 0x8a, 0x49, 0x0b, 0x08, 0x2f, 0xec, 0x22, 0xd7, 0x6c, 0x2e, 0xe4,
	0x03, 0x6a, 0xa5, 0x85, 0xb4, 0xf4, 0x38, 0xd4, 0xbe, 0x41, 0x73, 0x51, 0xac, 0xb8, 0x64, 0x1a,
	0xf9, 0x8c, 0x4f, 0x97, 0x48, 0x4f, 0x5c, 0xbe, 0x71, 0xf5, 0x61, 0xe7, 0xdc, 0xbe, 0x17, 0xdd,
	0x97, 0x9a, 0xd4, 0x72, 0x8b, 0x2b, 0x94, 0xb6, 0x7f, 0x40, 0xbe, 0x42, 0xe4, 0x95, 0xcc, 0x20,
	0x4a, 0x5a, 0x0f, 0xbd, 0xe7, 0x3b, 0xbd, 0xfe, 0x93, 0xba, 0xf2, 0x76, 0xdb, 0x6f, 0x38, 0xe3,
	0x4a, 0x2d, 0x45, 0xc6, 0xbd, 0x19, 0x66, 0x14, 0x66, 0x62, 0x2e, 0x32, 0x1a, 0x05, 0xc2, 0xe5,
	0xae, 0xeb, 0x27, 0x69, 0x5a, 0x2a, 0x77, 0x60, 0xc2, 0xa9, 0xad, 0xb0, 0x6b, 0x36, 0xc3, 0x6c,
	0xc9, 0x75, 0x90, 0x52, 0x78, 0x15, 0x36, 0x28, 0xa5, 0xdf, 0x9f, 0x94, 0x5b, 0xb0, 0xd6, 0x25,
	0xbc, 0x7b, 0xdd, 0x6c, 0x18, 0xed, 0x26, 0xf8, 0x7f, 0x89, 0xad, 0x8f, 0x70, 0xfa, 0xc2, 0x9d,
	0xd7, 0x85, 0x91, 0x2c, 0xb8, 0x59, 0x94, 0xba, 0x5f, 0xd0, 0xde, 0xe7, 0xe1, 0x25, 0x3a, 0x26,
	0xef, 0xe1, 0xed, 0xf6, 0x84, 0xfc, 0x0d, 0x57, 0x03, 0xab, 0x0f, 0xed, 0x7d, 0x16, 0xfc, 0xb2,
	0xa9, 0x62, 0xea, 0x1a, 0xd9, 0x1f, 0x5c, 0x97, 0xb0, 0x33, 0x88, 0x1f, 0x27, 0xf4, 0x48, 0xba,
	0xb8, 0x85, 0x37, 0xcf, 0xf7, 0xa9, 0x09, 0x70, 0x37, 0x62, 0x37, 0xa3, 0xe1, 0xb0, 0x77, 0x37,
	0x4e, 0x0e, 0x48, 0x03, 0x4e, 0x06, 0x29, 0x1b, 0xdf, 0x4f, 0x7a, 0x49, 0x85, 0xc4, 0x50, 0x77,
	0xc1, 0x8f, 0xee, 0x6d, 0xda, 0x4b, 0xaa, 0x24, 0x81, 0xd8, 0x45, 0xdd, 0xe1, 0xf5, 0xe0, 0xe7,
	0x64, 0x34, 0x49, 0x93, 0xda, 0x75, 0x63, 0xcb, 0xc3, 0xf4, 0x38, 0xbc, 0x85, 0x2f, 0xff, 0x02,
	0x00, 0x00, 0xff, 0xff, 0xc7, 0xca, 0xa4, 0x5b, 0x19, 0x03, 0x00, 0x00,
}
